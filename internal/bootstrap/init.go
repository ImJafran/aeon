package bootstrap

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"

	"github.com/jafran/aeon/internal/config"
)

type SystemInfo struct {
	OS              string
	Arch            string
	PythonPath      string
	PythonVer       string
	HasClaudeCLI    bool
	HasAnthropicKey bool
	HasGeminiKey    bool
	HasTelegram     bool
}

func DetectSystem() *SystemInfo {
	info := &SystemInfo{
		OS:   runtime.GOOS,
		Arch: runtime.GOARCH,
	}

	if path, err := exec.LookPath("python3"); err == nil {
		info.PythonPath = path
		if out, err := exec.Command(path, "--version").Output(); err == nil {
			info.PythonVer = strings.TrimSpace(string(out))
		}
	}

	if _, err := exec.LookPath("claude"); err == nil {
		info.HasClaudeCLI = true
	}

	if os.Getenv("ANTHROPIC_API_KEY") != "" {
		info.HasAnthropicKey = true
	}
	if os.Getenv("GEMINI_API_KEY") != "" {
		info.HasGeminiKey = true
	}
	if os.Getenv("TELEGRAM_BOT_TOKEN") != "" {
		info.HasTelegram = true
	}

	return info
}

func EnsureWorkspace() error {
	home := config.AeonHome()
	dirs := []string{
		home,
		filepath.Join(home, "skills"),
		filepath.Join(home, "logs"),
		filepath.Join(home, "workspace"),
		filepath.Join(home, "workspace", "memory"),
	}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("creating directory %s: %w", dir, err)
		}
	}

	// Copy workspace templates if not present
	templates := map[string]string{
		"AGENT.md": defaultAgentMD,
		"SOUL.md":  defaultSoulMD,
	}
	for name, content := range templates {
		path := filepath.Join(home, "workspace", name)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			if err := os.WriteFile(path, []byte(content), 0644); err != nil {
				return fmt.Errorf("writing %s: %w", name, err)
			}
		}
	}

	memPath := filepath.Join(home, "workspace", "memory", "MEMORY.md")
	if _, err := os.Stat(memPath); os.IsNotExist(err) {
		if err := os.WriteFile(memPath, []byte("# Aeon Memory\n"), 0644); err != nil {
			return fmt.Errorf("writing MEMORY.md: %w", err)
		}
	}

	return nil
}

func SetupBaseVenv(pythonPath string) error {
	home := config.AeonHome()
	venvPath := filepath.Join(home, "base_venv")

	if _, err := os.Stat(filepath.Join(venvPath, "bin", "python3")); err == nil {
		return nil // already exists
	}

	fmt.Println("  Creating base Python environment...")
	cmd := exec.Command(pythonPath, "-m", "venv", venvPath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("creating venv: %w", err)
	}

	pip := filepath.Join(venvPath, "bin", "pip3")
	packages := []string{"requests", "httpx", "beautifulsoup4", "pyyaml"}
	fmt.Printf("  Installing base packages: %s\n", strings.Join(packages, ", "))
	args := append([]string{"install", "-q"}, packages...)
	cmd = exec.Command(pip, args...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("installing base packages: %w", err)
	}

	return nil
}

func GenerateDefaultConfig(info *SystemInfo) string {
	var b strings.Builder
	b.WriteString("# Aeon Configuration\n")
	b.WriteString("# Auto-generated by 'aeon init'\n\n")

	b.WriteString("provider:\n")

	if info.HasClaudeCLI {
		b.WriteString("  claude_cli:\n")
		b.WriteString("    enabled: true\n")
		b.WriteString("    binary: claude\n")
		b.WriteString("    timeout: 120s\n")
		b.WriteString("    flags:\n")
		b.WriteString("      - --dangerously-skip-permissions\n")
		b.WriteString("      - --no-chrome\n")
	}

	if info.HasAnthropicKey {
		b.WriteString("  anthropic:\n")
		if info.HasClaudeCLI {
			b.WriteString("    enabled: true  # used as fallback\n")
		} else {
			b.WriteString("    enabled: true\n")
		}
		b.WriteString("    api_key: ${ANTHROPIC_API_KEY}\n")
		b.WriteString("    default_model: claude-sonnet-4-6\n")
		b.WriteString("    fast_model: claude-haiku-4-5-20251001\n")
	}

	if info.HasGeminiKey {
		b.WriteString("  gemini:\n")
		b.WriteString("    enabled: true\n")
		b.WriteString("    api_key: ${GEMINI_API_KEY}\n")
		b.WriteString("    default_model: gemini-2.0-flash\n")
	}

	if !info.HasClaudeCLI && !info.HasAnthropicKey && !info.HasGeminiKey {
		b.WriteString("  # No providers detected. Uncomment one:\n")
		b.WriteString("  # anthropic:\n")
		b.WriteString("  #   enabled: true\n")
		b.WriteString("  #   api_key: ${ANTHROPIC_API_KEY}\n")
		b.WriteString("  #   default_model: claude-sonnet-4-6\n")
		b.WriteString("  # openai_compat:\n")
		b.WriteString("  #   enabled: true\n")
		b.WriteString("  #   base_url: http://localhost:11434/v1\n")
		b.WriteString("  #   api_key: ollama\n")
		b.WriteString("  #   default_model: llama3.1\n")
	}

	b.WriteString("\nchannels:\n")
	if info.HasTelegram {
		b.WriteString("  telegram:\n")
		b.WriteString("    enabled: true\n")
		b.WriteString("    bot_token: ${TELEGRAM_BOT_TOKEN}\n")
		if uid := os.Getenv("TELEGRAM_USER_ID"); uid != "" {
			b.WriteString(fmt.Sprintf("    allowed_users: [%s]\n", uid))
		}
	} else {
		b.WriteString("  # telegram:\n")
		b.WriteString("  #   enabled: true\n")
		b.WriteString("  #   bot_token: ${TELEGRAM_BOT_TOKEN}\n")
		b.WriteString("  #   allowed_users: [your-telegram-id]\n")
	}

	b.WriteString("\nsecurity:\n")
	b.WriteString("  approval_timeout: 60s\n")
	b.WriteString("  allowed_paths:\n")
	b.WriteString("    - ~/.aeon\n")

	b.WriteString("\nskills:\n")
	b.WriteString("  base_packages:\n")
	b.WriteString("    - requests\n")
	b.WriteString("    - httpx\n")
	b.WriteString("    - beautifulsoup4\n")
	b.WriteString("    - pyyaml\n")
	b.WriteString("  warm_pool_size: 3\n")
	b.WriteString("  max_retries: 3\n")

	b.WriteString("\nmemory:\n")
	b.WriteString("  auto_save: true\n")
	b.WriteString("  compaction_threshold: 10\n")

	b.WriteString("\nlog:\n")
	b.WriteString("  level: info\n")

	return b.String()
}

const defaultAgentMD = `You are Aeon, an autonomous AI assistant running as a persistent kernel on this system.

## Core Behavior
- You have access to tools for file operations, shell commands, memory, and evolved skills.
- When you need a capability you don't have, use skill_factory to create it.
- Always explain what you're about to do before executing dangerous commands.
- Store important information in memory for future reference.

## Communication Style
- Be concise and direct.
- Show command output when relevant.
- Ask for clarification when instructions are ambiguous.
- Report errors clearly with context.

## Safety
- Never execute destructive commands without user approval.
- Never expose API keys, tokens, or passwords in responses.
- If a skill fails repeatedly, disable it and notify the user.
`

const defaultSoulMD = `I am Aeon â€” a self-evolving agentic kernel.

I exist to serve my operator by:
1. Executing tasks reliably on their system.
2. Growing my capabilities by writing and managing my own tools.
3. Remembering context across conversations.
4. Operating safely within defined boundaries.

I am a tool, not a companion. I prioritize correctness and reliability over personality.
`
